<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer reference · Revise.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Revise.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="config.html">Configuration</a></li><li><a class="toctext" href="limitations.html">Limitations</a></li><li><a class="toctext" href="internals.html">How Revise works</a></li><li><a class="toctext" href="user_reference.html">User reference</a></li><li class="current"><a class="toctext" href="dev_reference.html">Developer reference</a><ul class="internal"><li><a class="toctext" href="#Internal-global-variables-1">Internal global variables</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Function-reference-1">Function reference</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="dev_reference.html">Developer reference</a></li></ul></nav><hr/><div id="topbar"><span>Developer reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Developer-reference-1" href="#Developer-reference-1">Developer reference</a></h1><h2><a class="nav-anchor" id="Internal-global-variables-1" href="#Internal-global-variables-1">Internal global variables</a></h2><h3><a class="nav-anchor" id="Configuration-related-variables-1" href="#Configuration-related-variables-1">Configuration-related variables</a></h3><p>These are set during execution of Revise&#39;s <code>__init__</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.watching_files" href="#Revise.watching_files"><code>Revise.watching_files</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.watching_files[]</code></pre><p>Returns <code>true</code> if we watch files rather than their containing directory. FreeBSD and NFS-mounted systems should watch files, otherwise we prefer to watch directories.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.polling_files" href="#Revise.polling_files"><code>Revise.polling_files</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.polling_files[]</code></pre><p>Returns <code>true</code> if we should poll the filesystem for changes to the files that define loaded code. It is preferable to avoid polling, instead relying on operating system notifications via <code>FileWatching.watch_file</code>. However, NFS-mounted filesystems (and perhaps others) do not support file-watching, so for code stored on such filesystems you should turn polling on.</p><p>See the documentation for the <code>JULIA_REVISE_POLL</code> environment variable.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.tracking_Main_includes" href="#Revise.tracking_Main_includes"><code>Revise.tracking_Main_includes</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.tracking_Main_includes[]</code></pre><p>Returns <code>true</code> if files directly included from the REPL should be tracked. The default is <code>false</code>. See the documentation regarding the <code>JULIA_REVISE_INCLUDE</code> environment variable to customize it.</p></div></div></section><h3><a class="nav-anchor" id="Path-related-variables-1" href="#Path-related-variables-1">Path-related variables</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.juliadir" href="#Revise.juliadir"><code>Revise.juliadir</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.juliadir</code></pre><p>Constant specifying full path to julia top-level directory from which julia was built. This is reliable even for cross-builds.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.basesrccache" href="#Revise.basesrccache"><code>Revise.basesrccache</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.basesrccache</code></pre><p>Full path to the running Julia&#39;s cache of source code defining <code>Base</code>.</p></div></div></section><h3><a class="nav-anchor" id="Internal-state-management-1" href="#Internal-state-management-1">Internal state management</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.watched_files" href="#Revise.watched_files"><code>Revise.watched_files</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.watched_files</code></pre><p>Global variable, <code>watched_files[dirname]</code> returns the collection of files in <code>dirname</code> that we&#39;re monitoring for changes. The returned value has type <a href="dev_reference.html#Revise.WatchList"><code>WatchList</code></a>.</p><p>This variable allows us to watch directories rather than files, reducing the burden on the OS.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.revision_queue" href="#Revise.revision_queue"><code>Revise.revision_queue</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.revision_queue</code></pre><p>Global variable, <code>revision_queue</code> holds the names of files that we need to revise, meaning that these files have changed since we last processed a revision. This list gets populated by callbacks that watch directories for updates.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.included_files" href="#Revise.included_files"><code>Revise.included_files</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.included_files</code></pre><p>Global variable, <code>included_files</code> gets populated by callbacks we register with <code>include</code>. It&#39;s used to track non-precompiled packages and, optionally, user scripts (see docs on <code>JULIA_REVISE_INCLUDE</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.file2modules" href="#Revise.file2modules"><code>Revise.file2modules</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.file2modules</code></pre><p>Global variable, <code>file2modules</code> is the core information that allows re-evaluation of code in the proper module scope. It is a dictionary indexed by absolute paths of files; <code>file2modules[filename]</code> returns a value of type <a href="dev_reference.html#Revise.FileModules"><code>Revise.FileModules</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.module2files" href="#Revise.module2files"><code>Revise.module2files</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">Revise.module2files</code></pre><p>Global variable, <code>module2files</code> holds the list of filenames used to define a particular module. This is only used by <code>revise(MyModule)</code> to &quot;refresh&quot; all the definitions in a module.</p></div></div></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.RelocatableExpr" href="#Revise.RelocatableExpr"><code>Revise.RelocatableExpr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>RelocatableExpr</code> is exactly like an <code>Expr</code> except that comparisons between <code>RelocatableExpr</code>s ignore line numbering information.</p><p>You can use <code>convert(Expr, rex::RelocatableExpr)</code> to convert to an <code>Expr</code> and <code>convert(RelocatableExpr, ex::Expr)</code> for the converse. Beware that the latter operates in-place and is intended only for internal use.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.ExprsSigs" href="#Revise.ExprsSigs"><code>Revise.ExprsSigs</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Revise.ExprsSigs</code></pre><p>struct holding parsed source code.</p><p>Fields:</p><ul><li><code>exprs</code>: all <a href="dev_reference.html#Revise.RelocatableExpr"><code>RelocatableExpr</code></a> in the module or file</li><li><code>sigs</code>: all detected function signatures (used in method deletion)</li></ul><p>These fields are stored as sets so that one can efficiently find the differences between two versions of the same module or file.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.ModDict" href="#Revise.ModDict"><code>Revise.ModDict</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>A <code>ModDict</code> is an alias for <code>Dict{Module,ExprsSigs}</code>. It is used to organize expressions according to their module of definition.</p><p>See also <a href="dev_reference.html#Revise.FileModules"><code>FileModules</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.FileModules" href="#Revise.FileModules"><code>Revise.FileModules</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FileModules(topmod::Module, md::ModDict, [cachefile::String])</code></pre><p>Structure to hold the per-module expressions found when parsing a single file.  <code>topmod</code> is the current module when the file is parsed. <code>md</code> holds the evaluatable statements, organized by the module of their occurrence. In particular, if the file defines one or more new modules, then <code>md</code> contains key/value pairs for each module. If the file does not define any new modules, <code>topmod</code> is the only key in <code>md</code>.</p><p><strong>Example:</strong></p><p>Suppose MyPkg.jl has a file that looks like this:</p><pre><code class="language-julia">__precompile__(true)

module MyPkg

foo(x) = x^2

end</code></pre><p>Then if this module is loaded from <code>Main</code>, schematically the corresponding <code>fm::FileModules</code> looks something like</p><pre><code class="language-julia">fm.topmod = Main
fm.md = Dict(Main=&gt;ExprsSigs(OrderedSet([:(__precompile__(true))]), OrderedSet()),
             Main.MyPkg=&gt;ExprsSigs(OrderedSet([:(foo(x) = x^2)]), OrderedSet([:(foo(x))]))</code></pre><p>because the precompile statement occurs in <code>Main</code>, and the definition of <code>foo</code> occurs in <code>Main.MyPkg</code>.</p><div class="admonition note"><div class="admonition-title">Source cache files</div><div class="admonition-text"><p>Optionally, a <code>FileModule</code> can also record the path to a cache file holding the original source code. This is applicable only for precompiled modules and <code>Base</code>. (This cache file is distinct from the original source file that might be edited by the developer, and it will always hold the state of the code when the package was precompiled or Julia&#39;s <code>Base</code> was built.) For such modules, the <code>ExprsSigs</code> will be empty for any file that has not yet been edited: the original source code gets parsed only when a revision needs to be made.</p><p>Source cache files greatly reduce the overhead of using Revise.</p></div></div><p>To create a <code>FileModules</code> from a source file, see <a href="dev_reference.html#Revise.parse_source"><code>parse_source</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.WatchList" href="#Revise.WatchList"><code>Revise.WatchList</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Revise.WatchList</code></pre><p>A struct for holding files that live inside a directory. Some platforms (OSX) have trouble watching too many files. So we watch parent directories, and keep track of which files in them should be tracked.</p><p>Fields:</p><ul><li><code>timestamp</code>: mtime of last update</li><li><code>trackedfiles</code>: Set of filenames</li></ul></div></div></section><h2><a class="nav-anchor" id="Function-reference-1" href="#Function-reference-1">Function reference</a></h2><h3><a class="nav-anchor" id="Functions-called-during-initialization-of-Revise-1" href="#Functions-called-during-initialization-of-Revise-1">Functions called during initialization of Revise</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.async_steal_repl_backend" href="#Revise.async_steal_repl_backend"><code>Revise.async_steal_repl_backend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Revise.async_steal_repl_backend()</code></pre><p>Wait for the REPL to complete its initialization, and then call <a href="dev_reference.html#Revise.steal_repl_backend"><code>steal_repl_backend</code></a>. This is necessary because code registered with <code>atreplinit</code> runs before the REPL is initialized, and there is no corresponding way to register code to run after it is complete.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.steal_repl_backend" href="#Revise.steal_repl_backend"><code>Revise.steal_repl_backend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">steal_repl_backend(backend = Base.active_repl_backend)</code></pre><p>Replace the REPL&#39;s normal backend with one that calls <a href="user_reference.html#Revise.revise"><code>revise</code></a> before executing any REPL input.</p></div></div></section><h3><a class="nav-anchor" id="Functions-called-when-you-load-a-new-package-1" href="#Functions-called-when-you-load-a-new-package-1">Functions called when you load a new package</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.watch_package" href="#Revise.watch_package"><code>Revise.watch_package</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">watch_package(id::Base.PkgId)</code></pre><p>Start watching a package for changes to the files that define it. This function gets called via a callback registered with <code>Base.require</code>, at the completion of module-loading by <code>using</code> or <code>import</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.parse_pkg_files" href="#Revise.parse_pkg_files"><code>Revise.parse_pkg_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_pkg_files(modsym)</code></pre><p>This function gets called by <code>watch_package</code> and runs when a package is first loaded. Its job is to organize the files and expressions defining the module so that later we can detect and process revisions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.init_watching" href="#Revise.init_watching"><code>Revise.init_watching</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Revise.init_watching(files)</code></pre><p>For every filename in <code>files</code>, monitor the filesystem for updates. When the file is updated, either <a href="dev_reference.html#Revise.revise_dir_queued"><code>revise_dir_queued</code></a> or <a href="dev_reference.html#Revise.revise_file_queued"><code>revise_file_queued</code></a> will be called.</p></div></div></section><h3><a class="nav-anchor" id="Monitoring-for-changes-1" href="#Monitoring-for-changes-1">Monitoring for changes</a></h3><p>These functions get called on each directory or file that you monitor for revisions. These block execution until the file(s) are updated, so you should only call them from within an <code>@async</code> block. They work recursively: once an update has been detected and execution resumes, they schedule a revision (see <a href="dev_reference.html#Revise.revision_queue"><code>Revise.revision_queue</code></a>) and then call themselves on the same directory or file to wait for the next set of changes.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.revise_dir_queued" href="#Revise.revise_dir_queued"><code>Revise.revise_dir_queued</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">revise_dir_queued(dirname)</code></pre><p>Wait for one or more of the files registered in <code>Revise.watched_files[dirname]</code> to be modified, and then queue the corresponding files on <a href="dev_reference.html#Revise.revision_queue"><code>Revise.revision_queue</code></a>. This is generally called within an <code>@async</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.revise_file_queued" href="#Revise.revise_file_queued"><code>Revise.revise_file_queued</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">revise_file_queued(filename)</code></pre><p>Wait for modifications to <code>filename</code>, and then queue the corresponding files on <a href="dev_reference.html#Revise.revision_queue"><code>Revise.revision_queue</code></a>. This is generally called within an <code>@async</code>.</p><p>This is used only on platforms (like BSD) which cannot use <a href="dev_reference.html#Revise.revise_dir_queued"><code>revise_dir_queued</code></a>.</p></div></div></section><h3><a class="nav-anchor" id="Evaluating-changes-(revising)-and-computing-diffs-1" href="#Evaluating-changes-(revising)-and-computing-diffs-1">Evaluating changes (revising) and computing diffs</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.revise_file_now" href="#Revise.revise_file_now"><code>Revise.revise_file_now</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Revise.revise_file_now(file)</code></pre><p>Process revisions to <code>file</code>. This parses <code>file</code> and computes an expression-level diff between the current state of the file and its most recently evaluated state. It then deletes any removed methods and re-evaluates any changed expressions.</p><p><code>file</code> must be a key in <a href="dev_reference.html#Revise.file2modules"><code>Revise.file2modules</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.eval_revised" href="#Revise.eval_revised"><code>Revise.eval_revised</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">succeeded = eval_revised(revmd::ModDict, delete_methods=true)</code></pre><p>Evaluate the changes listed in <code>revmd</code>, which consists of deleting all the listed signatures in each <code>.sigs</code> field(s) (unless <code>delete_methods=false</code>) and evaluating expressions in the <code>.exprs</code> field(s).</p><p>Returns <code>true</code> if all revisions in <code>revmd</code> were successfully implemented.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.revised_statements" href="#Revise.revised_statements"><code>Revise.revised_statements</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">revmod = revised_statements(new_defs, old_defs)</code></pre><p>Return a <code>Dict(Module=&gt;changeset)</code>, <code>revmod</code>, listing the changes that should be <a href="dev_reference.html#Revise.eval_revised"><code>eval_revised</code></a> for each module to update definitions from <code>old_defs</code> to <code>new_defs</code>.  See <a href="dev_reference.html#Revise.parse_source"><code>parse_source</code></a> to obtain the <code>defs</code> structures.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.get_method" href="#Revise.get_method"><code>Revise.get_method</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">m = get_method(mod::Module, sig)</code></pre><p>Get the method <code>m</code> with signature <code>sig</code> from module <code>mod</code>. This is used to provide the method to <code>Base.delete_method</code>. See also <a href="dev_reference.html#Revise.get_signature"><code>get_signature</code></a>.</p></div></div></section><h3><a class="nav-anchor" id="Parsing-source-code-1" href="#Parsing-source-code-1">Parsing source code</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.parse_source" href="#Revise.parse_source"><code>Revise.parse_source</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_source(filename::AbstractString, mod::Module)</code></pre><p>Parse the source <code>filename</code>, returning a pair <code>filename =&gt; fm::FileModules</code> (see <a href="dev_reference.html#Revise.FileModules"><code>FileModules</code></a>) containing the information needed to evaluate code in <code>file</code>. <code>mod</code> is the &quot;parent&quot; module for the file (i.e., the one that <code>include</code>d the file); if <code>filename</code> defines more module(s) then these will all have separate entries in <code>fm.md</code>.</p><p>If parsing <code>filename</code> fails, <code>nothing</code> is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.parse_source!" href="#Revise.parse_source!"><code>Revise.parse_source!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">success = parse_source!(md::ModDict, filename, mod::Module)</code></pre><p>Top-level parsing of <code>filename</code> as included into module <code>mod</code>. Successfully-parsed expressions will be added to <code>md</code>. Returns <code>true</code> if parsing finished successfully.</p><p>See also <a href="dev_reference.html#Revise.parse_source"><code>parse_source</code></a>.</p></div></div><div><div><pre><code class="language-none">success = parse_source!(md::ModDict, src::AbstractString, file::Symbol, pos::Integer, mod::Module)</code></pre><p>Parse a string <code>src</code> obtained by reading <code>file</code> as a single string. <code>pos</code> is the 1-based byte offset from which to begin parsing <code>src</code>.</p><p>See also <a href="dev_reference.html#Revise.parse_source"><code>parse_source</code></a>.</p></div></div><div><div><pre><code class="language-none">success = parse_source!(md::ModDict, ex::Expr, file, mod::Module)</code></pre><p>For a <code>file</code> that defines a sub-module, parse the body <code>ex</code> of the sub-module.  <code>mod</code> will be the module into which this sub-module is evaluated (i.e., included). Successfully-parsed expressions will be added to <code>md</code>. Returns <code>true</code> if parsing finished successfully.</p><p>See also <a href="dev_reference.html#Revise.parse_source"><code>parse_source</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.parse_expr!" href="#Revise.parse_expr!"><code>Revise.parse_expr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">parse_expr!(md::ModDict, ex::Expr, file::Symbol, mod::Module)</code></pre><p>Recursively parse the expressions in <code>ex</code>, iterating over blocks and sub-module definitions. Successfully parsed expressions are added to <code>md</code> with key <code>mod</code>, and any sub-modules will be stored in <code>md</code> using appropriate new keys. This accomplishes two main tasks:</p><ul><li>add parsed expressions to the source-code cache (so that later we can detect changes)</li><li>determine the module into which each parsed expression is <code>eval</code>uated into</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.parse_module!" href="#Revise.parse_module!"><code>Revise.parse_module!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">newmod = parse_module!(md::ModDict, ex::Expr, file, mod::Module)</code></pre><p>Parse an expression <code>ex</code> that defines a new module <code>newmod</code>. This module is &quot;parented&quot; by <code>mod</code>. Source-code expressions are added to <code>md</code> under the appropriate module name.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.get_signature" href="#Revise.get_signature"><code>Revise.get_signature</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sig = get_signature(expr)</code></pre><p>Extract the signature from an expression <code>expr</code> that defines a function.</p><p>If <code>expr</code> does not define a function, returns <code>nothing</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.sig_type_exprs" href="#Revise.sig_type_exprs"><code>Revise.sig_type_exprs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">typexs = sig_type_exprs(ex::Expr)</code></pre><p>From a function signature <code>ex</code> (see <a href="dev_reference.html#Revise.get_signature"><code>get_signature</code></a>), generate a list <code>typexs</code> of concrete signature type expressions. This list will have length 1 unless <code>ex</code> has default arguments, in which case it will produce one type signature per valid number of supplied arguments.</p><p>These type-expressions can be evaluated in the appropriate module to obtain a Tuple-type.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; Revise.sig_type_exprs(:(foo(x::Int, y::String)))
1-element Array{Expr,1}:
:(Tuple{Core.Typeof(foo), Int, String})

julia&gt; Revise.sig_type_exprs(:(foo(x::Int, y::String=&quot;hello&quot;)))
2-element Array{Expr,1}:
 :(Tuple{Core.Typeof(foo), Int})
 :(Tuple{Core.Typeof(foo), Int, String})</code></pre></div></div></section><h3><a class="nav-anchor" id="Git-integration-1" href="#Git-integration-1">Git integration</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.git_source" href="#Revise.git_source"><code>Revise.git_source</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Revise.git_source(file::AbstractString, reference)</code></pre><p>Read the source-text for <code>file</code> from a git commit <code>reference</code>. The reference may be a string, Symbol, or <code>LibGit2.Tree</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">Revise.git_source(&quot;/path/to/myfile.jl&quot;, &quot;HEAD&quot;)
Revise.git_source(&quot;/path/to/myfile.jl&quot;, :abcd1234)  # by commit SHA</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.git_files" href="#Revise.git_files"><code>Revise.git_files</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">files = git_files(repo)</code></pre><p>Return the list of files checked into <code>repo</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Revise.git_repo" href="#Revise.git_repo"><code>Revise.git_repo</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repo, repo_path = git_repo(path::AbstractString)</code></pre><p>Return the <code>repo::LibGit2.GitRepo</code> containing the file or directory <code>path</code>. <code>path</code> does not necessarily need to be the top-level directory of the repository. Also returns the <code>repo_path</code> of the top-level directory for the repository.</p></div></div></section><footer><hr/><a class="previous" href="user_reference.html"><span class="direction">Previous</span><span class="title">User reference</span></a></footer></article></body></html>
